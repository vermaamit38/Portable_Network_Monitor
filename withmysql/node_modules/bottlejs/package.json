{
  "name": "bottlejs",
  "version": "1.2.3",
  "description": "A powerful dependency injection micro container",
  "main": "dist/bottle.js",
  "typings": "dist/bottle.d.ts",
  "scripts": {
    "test": "grunt test"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/young-steveo/bottlejs.git"
  },
  "keywords": [
    "di",
    "dependency",
    "injection",
    "micro",
    "angular",
    "pimple"
  ],
  "author": {
    "name": "Stephen Young",
    "email": "young.steveo@gmail.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/young-steveo/bottlejs/issues"
  },
  "homepage": "https://github.com/young-steveo/bottlejs",
  "devDependencies": {
    "grunt": "^0.4.5",
    "grunt-contrib-clean": "^0.6.0",
    "grunt-contrib-concat": "^0.5.0",
    "grunt-contrib-jasmine": "^0.7.0",
    "grunt-contrib-jshint": "^0.10.0",
    "grunt-contrib-uglify": "^0.5.1",
    "grunt-wrap": "^0.3.0",
    "lodash": "^2.4.1"
  },
  "readme": "\n![BottleJS](/bottle-logo.jpg)\n# BottleJS [![Build Status](https://travis-ci.org/young-steveo/bottlejs.svg?branch=master)](https://travis-ci.org/young-steveo/bottlejs)\n\n> A powerful dependency injection micro container\n\n## Introduction\n\nBottleJS is a tiny, powerful dependency injection container.  It features lazy loading, middleware hooks, decorators and a clean api inspired by the [AngularJS Module API](https://docs.angularjs.org/api/ng/type/angular.Module) and the simple PHP library [Pimple](http://pimple.sensiolabs.org/).  You'll like BottleJS if you enjoy:\n\n* building a stack from components rather than a kitchen-sink framework.\n* uncoupled objects and dependency injection.\n* an API that makes sense.\n* lazily loaded objects.\n* trying cool stuff :smile:\n\n## Browser Support\n\nBottleJS supports IE9+ and other ECMAScript 5 compliant browsers.\n\n## Installation\n\nBottleJS can be used in a browser or in a nodejs app.  It can be installed via bower or npm:\n\n```bash\n$ bower install bottlejs\n```\n\n```bash\n$ npm install bottlejs\n```\n\n## Simple Example\n\nThe simplest recipe to get started with is `Bottle#service`.  Say you have a constructor for a service object:\n\n```js\nvar Beer = function() { /* A beer service, :yum: */ };\n```\n\nYou can register the constructor with `Bottle#service`:\n\n```js\nvar bottle = new Bottle();\nbottle.service('Beer', Beer);\n```\n\nLater, when you need the constructed service, you just access the `Beer` property like this:\n\n```js\nbottle.container.Beer;\n```\n\nA lot happened behind the scenes:\n\n1. Bottle created a provider containing a factory function when you registered the Beer service.\n2. When the `bottle.container.Beer` property was accessed, Bottle looked up the provider and executed the factory to build and return the Beer service.\n3. The provider and factory were deleted, and the `bottle.container.Beer` property was set to be the Beer service instance.  Accessing `bottle.container.Beer` in the future becomes a simple property lookup.\n\n## Injecting Dependencies\n\nThe above example is simple.  But, what if the Beer service had dependencies?  For example:\n\n```js\nvar Barley = function() {};\nvar Hops = function() {};\nvar Water = function() {};\nvar Beer = function(barley, hops, water) { /* A beer service, :yum: */ };\n```\n\nYou can register services with `Bottle#service` and include dependencies like this:\n\n```js\nvar bottle = new Bottle();\nbottle.service('Barley', Barley);\nbottle.service('Hops', Hops);\nbottle.service('Water', Water);\nbottle.service('Beer', Beer, 'Barley', 'Hops', 'Water');\n```\n\nNow, when you access `bottle.container.Beer`, Bottle will lazily load all of the dependencies and inject them into your Beer service before returning it.\n\n### Service Factory\n\nIf you need more complex logic when generating a service, you can register a factory instead.  A factory function receives the container as an argument, and should return your constructed service:\n\n```js\nvar bottle = new Bottle();\nbottle.service('Barley', Barley);\nbottle.service('Hops', Hops);\nbottle.service('Water', Water);\nbottle.factory('Beer', function(container) {\n    var barley = container.Barley;\n    var hops = container.Hops;\n    var water = container.Water;\n\n    barley.halved();\n    hops.doubled();\n    water.spring();\n    return new Beer(barley, hops, water);\n});\n```\n\n### Service Provider\n\nThis is the meat of the Bottle library.  The above methods `Bottle#service` and `Bottle#factory` are just shorthand for the provider function.  You usually can get by with the simple functions above, but if you really need more granular control of your services in different environments, regiser them as a provider.  To use it, pass a constructor for the provider that exposes a `$get` function.  The `$get` function is used as a factory to build your service.\n\n```js\nvar bottle = new Bottle();\nbottle.service('Barley', Barley);\nbottle.service('Hops', Hops);\nbottle.service('Water', Water);\nbottle.provider('Beer', function() {\n    // This environment may not support water.\n    // We should polyfill it.\n    if (waterNotSupported) {\n        Beer.pollyfillWater();\n    }\n\n    // this is the service factory.\n    this.$get = function(container) {\n        var barley = container.Barley;\n        var hops = container.Hops;\n        var water = container.Water;\n\n        barley.halved();\n        hops.doubled();\n        water.spring();\n        return new Beer(barley, hops, water);\n    };\n});\n```\n\n## Decorators\n\nBottle supports injecting decorators into the provider pipeline with the `Bottle#decorator` method.  Bottle decorators are just simple functions that intercept a service in the provider phase after it has been created, but before it is accessed for the first time.  The function should return the service, or another object to be used as the service instead.\n\n```js\nvar bottle = new Bottle();\nbottle.service('Beer', Beer);\nbottle.service('Wine', Wine);\nbottle.decorator(function(service) {\n    // this decorator will be run for both Beer and Wine services.\n    service.stayCold();\n    return service;\n});\n\nbottle.decorator('Wine', function(wine) {\n    // this decorator will only affect the Wine service.\n    wine.unCork();\n    return wine;\n});\n```\n\n## Middleware\n\nBottle middleware are similar to decorators, but they are executed every time a service is accessed from the container.  They are passed the service instance and a `next` function:\n\n```js\nvar bottle = new Bottle();\nbottle.service('Beer', Beer);\nbottle.middleware(function(service, next) {\n    // this middleware will be executed for all services\n    console.log('A service was accessed!');\n    next();\n});\n\nbottle.middleware('Beer', function(beer, next) {\n    // this middleware will only affect the Beer service.\n    console.log('Beer?  Nice.  Tip your bartender...');\n    next();\n});\n```\n\nMiddleware can pass an error object to the `next` function, and bottle will throw the error:\n\n```js\nvar bottle = new Bottle();\nbottle.service('Beer', Beer);\nbottle.middleware('Beer', function(beer, next) {\n    if (beer.hasGoneBad()) {\n        return next(new Error('The Beer has gone bad!'));\n    }\n    next();\n});\n\n// results in Uncaught Error: The Beer has gone bad!(â€¦)\n```\n\n## Nested Bottles\nBottle will generate nested containers if dot notation is used in the service name.  A sub container will be created for you based on the name given:\n\n```js\nvar bottle = new Bottle();\nvar IPA = function() {};\nbottle.service('Beer.IPA', IPA);\nbottle.container.Beer; // this is a new Bottle.container object\nbottle.container.Beer.IPA; // the service\n```\n\n## API\n\n### Bottle\n\n#### pop([name])\n\nUsed to get an instance of bottle.  If a name is passed, bottle will return the same instance.  Calling the Bottle constructor as a function will call and return return `Bottle.pop`, so `Bottle.pop('Soda') === Bottle('Soda')`\n\nParam                      | Type       | Details\n:--------------------------|:-----------|:--------\n**name**<br />*(optional)* | *String*   | The name of the bottle. If passed, bottle will store the instance internally and return the same instance if `Bottle.pop` is subsequently called with the same name.\n\n#### config\n\nA global configuration object.\n\nProperty   | Type      | Default | Details\n:----------|:----------|:--------|:--------\n**strict** | *Boolean* | `false` | Enables strict mode.  Currently only verifies that automatically injected dependencies are not undefined.\n\n### Bottle.prototype\n\n#### constant(name, value)\n\nUsed to add a read only value to the container.\n\nParam     | Type       | Details\n:---------|:-----------|:--------\n**name**  | *String*   | The name of the constant.  Must be unique to each Bottle instance.\n**value** | *Mixed*    | A value that will be defined as enumerable, but not writable.\n\n#### decorator(name, func)\n\nUsed to register a decorator function that the provider will use to modify your services at creation time.\n\nParam                      | Type       | Details\n:--------------------------|:-----------|:--------\n**name**<br />*(optional)* | *String*   | The name of the service this decorator will affect. Will run for all services if not passed.\n**func**                   | *Function* | A function that will accept the service as the first parameter.  Should return the service, or a new object to be used as the service.\n\n#### defer(func)\n\nRegister a function to be executed when `Bottle#resolve` is called.\n\nParam    | Type       | Details\n:--------|:-----------|:--------\n**func** | *Function* | A function to be called later.  Will be passed a value given to `Bottle#resolve`.\n\n#### digest(services)\n\nImmediately instantiate an array of services and return their instances\nin the order of the array of instances.\n\nParam        | Type    | Details\n:------------|:--------|:--------\n**services** | *Array* | Array of services that should be instantiated.\n\n#### factory(name, Factory)\n\nUsed to register a service factory\n\nParam       | Type       | Details\n:-----------|:-----------|:--------\n**name**    | *String*   | The name of the service.  Must be unique to each Bottle instance.\n**Factory** | *Function* | A function that should return the service object.  Will only be called once; the Service will be a singleton.  Gets passed an instance of the container to allow dependency injection when creating the service.\n\n#### middleware(name, func)\n\nUsed to register a middleware function.  This function will be executed every time the service is accessed.\n\nParam                      | Type       | Details\n:--------------------------|:-----------|:--------\n**name**<br />*(optional)* | *String*   | The name of the service for which this middleware will be called. Will run for all services if not passed.\n**func**                   | *Function* | A function that will accept the service as the first parameter, and a `next` function as the second parameter.  Should execute `next()` to allow other middleware in the stack to execute.  Bottle will throw anything passed to the `next` function, i.e. `next(new Error('error msg'))`.\n\n#### provider(name, Provider)\n\nUsed to register a service provider\n\nParam        | Type       | Details\n:------------|:-----------|:--------\n**name**     | *String*   | The name of the service.  Must be unique to each Bottle instance.\n**Provider** | *Function* | A constructor function that will be instantiated as a singleton.  Should expose a function called `$get` that will be used as a factory to instantiate the service.\n\n#### register(Obj)\n#### container.$register(Obj)\n\nUsed to register a service, factory, provider, or value based on properties of the Obj.  `bottle.container.$register` is an alias of `bottle.register`; this allows factories and providers to register multiple services on the container without needing access to the bottle instance itself.\n\nIf `Bottle.config.strict` is set to `true`, this method will throw an error if an injected dependency is `undefined`.\n\nParam   | Type       | Details\n:-------|:-----------|:--------\n**Obj** | *Object*\\|*Function* | An object or constructor with one of several properties:<br /><ul><li>**Obj.$name** &mdash; *required* &mdash; the name used to register the object</li><li>**Obj.$type** &mdash; *optional* &mdash; the method used to register the object.  Defaults to `'service'` in which case the Obj will be treated as a constructor. Valid types are: `'service'`, `'factory'`, `'provider'`, `'value'`</li><li>**Obj.$inject** &mdash; *optional* &mdash; If `Obj.$type` is `'service'`, this property can be a string name or an array of names of dependencies to inject into the constructor.<br />E.g. `Obj.$inject = ['dep1', 'dep2'];`</li><li>**Obj.$value** &mdash; *optional* &mdash; Normally Obj is registered on the container.  However, if this property is included, it's value will be registered on the container instead of the object itself.  Useful for registering objects on the bottle container without modifying those objects with bottle specific keys.</li></ul>\n\n#### resolve(data)\n\nExecute any deferred functions registered by `Bottle#defer`.\n\nParam                      | Type    | Details\n:--------------------------|:--------|:--------\n**data**<br />*(optional)* | *Mixed* | Value to be passed to each deferred function as the first parameter.\n\n#### service(name, Constructor [, dependency [, ...]])\n\nUsed to register a service constructor.  If `Bottle.config.strict` is set to `true`, this method will throw an error if an injected dependency is `undefined`.\n\nParam                            | Type       | Details\n:--------------------------------|:-----------|:--------\n**name**                         | *String*   | The name of the service.  Must be unique to each Bottle instance.\n**Constructor**                  | *Function* | A constructor function that will be instantiated as a singleton.\n**dependency**<br />*(optional)* | *String*   | An optional name for a dependency to be passed to the constructor.  A dependency will be passed to the constructor for each name passed to `Bottle#service` in the order they are listed.\n\n#### value(name, val)\n\nUsed to add an arbitrary value to the container.\n\nParam    | Type     | Details\n:--------|:---------|:--------\n**name** | *String* | The name of the value.  Must be unique to each Bottle instance.\n**val**  | *Mixed*  | A value that will be defined as enumerable, but not writable.\n\n## TypeScript\n\nA TypeScript declaration file is bundled with this package. To get TypeScript to resolve it automatically, you need to set `moduleResolution` to `node` in your `tsconfig.json`. \n",
  "readmeFilename": "README.md",
  "_id": "bottlejs@1.2.3",
  "dist": {
    "shasum": "9a0bda27d0ec6ce63398070f1f61f9f9c97c03e7"
  },
  "_from": "bottlejs@",
  "_resolved": "https://registry.npmjs.org/bottlejs/-/bottlejs-1.2.3.tgz"
}
